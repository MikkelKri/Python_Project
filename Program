
#!/usr/bin/env python3

#Open gene 2 pubmed
#open geneinfo
#Ask for a tax id
	#check for error
	
#filter gene_info data for that tax id
#filter gene2pubmed for that tax id
#Save these two files as temporary filtering/selection files (Is this the efficient way)


#Genes are linked if mentioned in the same pubmed article -- one exercise
	#pubmed_article  gene_number  gene_name	description
	#output for a network is .sif gene pp gene
	#need additional output file for network description
#The weight of gene linkage is calculated by the number of times the two genes are mentioned together - another exercise
	#genename(pp)genename  confidence_score
	#output for a score is .txt
	
	
#The file for cytoscape needs to be further filtered.  
#present which genes have the most connections?  Select from that?
#maybe if a network has more than 50 genes get rid of the connections that are only mentioned once?

#######################################################################################################################

import sys

try:
	tax = str(sys.argv[1])
	print("The taxonomy id you have entered is: ", tax)
	response = input("Is that correct? Please enter y or n: ")
	if response.upper() == "Y":
		print("Please be patient while we efficiently filter the database")
	else:
		print("Please start over and enter the correct tax id.")
		sys.exit(1)
		
except ValueError:
	print('You must supply one taxonomy id')
	sys.exit(1)
except IndexError:
	print('You must supply one taxonomy id')
	sys.exit(1)

#filter
pubmedlist = open("gene2pubmed", 'r')
#filter for the tax id in the first column

#Load the gene and the pubmedID into a list
pubmedtmp = []

for line in pubmedlist:
	if line.startswith(tax + "	"):
		line = line.strip().split('\t')
		pubmedtmp.append(line[1:])

#Convert the list into a dict, with pubmedID as the key and all the genes as values
pubmedID_dict = {}
for line in pubmedtmp:
	if line[1] in pubmedID_dict:
		pubmedID_dict[line[1]].append(int(line[0]))
	else:
		pubmedID_dict[line[1]] = [line[0]]
		
#removing all the pubmed key/value pairs if there is only one value (gene)
keylist = list(pubmedID_dict.keys())
for i in keylist:
	if len(pubmedID_dict[i]) <2:
		del	pubmedID_dict[i]
			
#print(pubmedID_dict)

# This finds all the possible pairs of genes linked by articles
pairlist = []
tuple_dict = {}

for kvpair in pubmedID_dict.items():
	pre = ([sorted((kvpair[1][a], kvpair[1][b])) for a in range(len(kvpair[1])) for b in range(a+1, len(kvpair[1]))])
	pairlist.append([tuple(k) for k in pre])

#This converts the list of lists into a flat list of tuples
flatlist = [no for row in pairlist for no in row]

#OPTION 1
#This makes a dict of tuples and counts of article links - it's good for quickly seeing which PPI have the most links
#We may not need this, we may just want the dict of dict
for j in flatlist:
	if j in tuple_dict:
		tuple_dict[j] += 1
	else:
		tuple_dict[j] = 1	
print(tuple_dict)


#OPTION 2
#This creates a dict of dict, it's probably better for finding the largest groups of protein-protein pairs.
#We may want to use this because I think it will be easier to create cytoscape files from here
PPIdict = {}
for a,b in flatlist:
	if a not in PPIdict:
		PPIdict[a] = {}
		PPIdict[a][b] = 1
	elif b in PPIdict[a]:
		PPIdict[a][b] += 1
	else:
		PPIdict[a][b] = 1
print(PPIdict)

#########################################################
Below these lines is extra code which may be useful
#########################################################
#########################################################


#sort by the pubmed id
def sort_key(row):
    return row[2]
pubmedtmp.sort(key = sort_key)



#inserting PubmeID into dict
pubmeID={}
for item in pubmedtmp:
	if item[2] not in pubmeID:
		pubmeID[item[2]] = {}
#print(pubmeID)

#temp code for testing equivalence in list of list
n = 0
for item in pubmedtmp[0:-1]:
	if pubmedtmp[n][2] == pubmedtmp[n+1][2]:
		print("true")
		n += 1
	else:
		n += 1
		continue

for k in pubdict.keys():

